/**
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package digitaltwins.implementation;

import retrofit2.Retrofit;
import .DigitalTwins;
import .models.DigitalTwinsAddHeaders;
import .models.DigitalTwinsAddRelationshipHeaders;
import .models.DigitalTwinsGetByIdHeaders;
import .models.DigitalTwinsGetComponentHeaders;
import .models.DigitalTwinsGetRelationshipByIdHeaders;
import .models.DigitalTwinsUpdateComponentHeaders;
import .models.DigitalTwinsUpdateHeaders;
import .models.DigitalTwinsUpdateRelationshipHeaders;
import .models.ErrorResponseException;
import .models.IncomingRelationshipCollection;
import .models.RelationshipCollection;
import com.google.common.reflect.TypeToken;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.ServiceResponseWithHeaders;
import com.microsoft.rest.Validator;
import java.io.IOException;
import java.util.List;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.PATCH;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in DigitalTwins.
 */
public class DigitalTwinsImpl implements DigitalTwins {
    /** The Retrofit service to perform REST calls. */
    private DigitalTwinsService service;
    /** The service client containing this operation class. */
    private AzureDigitalTwinsAPIImpl client;

    /**
     * Initializes an instance of DigitalTwins.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public DigitalTwinsImpl(Retrofit retrofit, AzureDigitalTwinsAPIImpl client) {
        this.service = retrofit.create(DigitalTwinsService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for DigitalTwins to be
     * used by Retrofit to perform actually REST calls.
     */
    interface DigitalTwinsService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: .DigitalTwins getById" })
        @GET("digitaltwins/{id}")
        Observable<Response<ResponseBody>> getById(@Path("id") String id, @Query("api-version") String apiVersion);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: .DigitalTwins add" })
        @PUT("digitaltwins/{id}")
        Observable<Response<ResponseBody>> add(@Path("id") String id, @Body Object twin, @Header("If-None-Match") String ifNoneMatch, @Query("api-version") String apiVersion);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: .DigitalTwins delete" })
        @HTTP(path = "digitaltwins/{id}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> delete(@Path("id") String id, @Header("If-Match") String ifMatch, @Query("api-version") String apiVersion);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: .DigitalTwins update" })
        @PATCH("digitaltwins/{id}")
        Observable<Response<ResponseBody>> update(@Path("id") String id, @Body List<Object> patchDocument, @Header("If-Match") String ifMatch, @Query("api-version") String apiVersion);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: .DigitalTwins getRelationshipById" })
        @GET("digitaltwins/{id}/relationships/{relationshipId}")
        Observable<Response<ResponseBody>> getRelationshipById(@Path("id") String id, @Path("relationshipId") String relationshipId, @Query("api-version") String apiVersion);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: .DigitalTwins addRelationship" })
        @PUT("digitaltwins/{id}/relationships/{relationshipId}")
        Observable<Response<ResponseBody>> addRelationship(@Path("id") String id, @Path("relationshipId") String relationshipId, @Body Object relationship, @Header("If-None-Match") String ifNoneMatch, @Query("api-version") String apiVersion);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: .DigitalTwins deleteRelationship" })
        @HTTP(path = "digitaltwins/{id}/relationships/{relationshipId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteRelationship(@Path("id") String id, @Path("relationshipId") String relationshipId, @Header("If-Match") String ifMatch, @Query("api-version") String apiVersion);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: .DigitalTwins updateRelationship" })
        @PATCH("digitaltwins/{id}/relationships/{relationshipId}")
        Observable<Response<ResponseBody>> updateRelationship(@Path("id") String id, @Path("relationshipId") String relationshipId, @Body List<Object> patchDocument, @Header("If-Match") String ifMatch, @Query("api-version") String apiVersion);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: .DigitalTwins listRelationships" })
        @GET("digitaltwins/{id}/relationships")
        Observable<Response<ResponseBody>> listRelationships(@Path("id") String id, @Query("relationshipName") String relationshipName, @Query("api-version") String apiVersion);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: .DigitalTwins listIncomingRelationships" })
        @GET("digitaltwins/{id}/incomingrelationships")
        Observable<Response<ResponseBody>> listIncomingRelationships(@Path("id") String id, @Query("api-version") String apiVersion);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: .DigitalTwins sendTelemetry" })
        @POST("digitaltwins/{id}/telemetry")
        Observable<Response<ResponseBody>> sendTelemetry(@Path("id") String id, @Body Object telemetry, @Header("dt-id") String dtId, @Header("dt-timestamp") String dtTimestamp, @Query("api-version") String apiVersion);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: .DigitalTwins sendComponentTelemetry" })
        @POST("digitaltwins/{id}/components/{componentPath}/telemetry")
        Observable<Response<ResponseBody>> sendComponentTelemetry(@Path("id") String id, @Path("componentPath") String componentPath, @Body Object telemetry, @Header("dt-id") String dtId, @Header("dt-timestamp") String dtTimestamp, @Query("api-version") String apiVersion);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: .DigitalTwins getComponent" })
        @GET("digitaltwins/{id}/components/{componentPath}")
        Observable<Response<ResponseBody>> getComponent(@Path("id") String id, @Path("componentPath") String componentPath, @Query("api-version") String apiVersion);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: .DigitalTwins updateComponent" })
        @PATCH("digitaltwins/{id}/components/{componentPath}")
        Observable<Response<ResponseBody>> updateComponent(@Path("id") String id, @Path("componentPath") String componentPath, @Body List<Object> patchDocument, @Header("If-Match") String ifMatch, @Query("api-version") String apiVersion);

    }

    /**
     * Retrieves a digital twin.
     Status codes:
     200 (OK): Success.
     404 (Not Found): There is no digital twin with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getById(String id) {
        return getByIdWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Retrieves a digital twin.
     Status codes:
     200 (OK): Success.
     404 (Not Found): There is no digital twin with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getByIdAsync(String id, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getByIdWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Retrieves a digital twin.
     Status codes:
     200 (OK): Success.
     404 (Not Found): There is no digital twin with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getByIdAsync(String id) {
        return getByIdWithServiceResponseAsync(id).map(new Func1<ServiceResponseWithHeaders<Object, DigitalTwinsGetByIdHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, DigitalTwinsGetByIdHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Retrieves a digital twin.
     Status codes:
     200 (OK): Success.
     404 (Not Found): There is no digital twin with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, DigitalTwinsGetByIdHeaders>> getByIdWithServiceResponseAsync(String id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.getById(id, this.client.apiVersion())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, DigitalTwinsGetByIdHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, DigitalTwinsGetByIdHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, DigitalTwinsGetByIdHeaders> clientResponse = getByIdDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, DigitalTwinsGetByIdHeaders> getByIdDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(ErrorResponseException.class)
                .buildWithHeaders(response, DigitalTwinsGetByIdHeaders.class);
    }

    /**
     * Adds or replaces a digital twin.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     412 (Precondition Failed): The model is decommissioned or the digital twin already exists (when using If-None-Match: *).
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param twin The digital twin instance being added. If provided, the $dtId property is ignored.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object add(String id, Object twin) {
        return addWithServiceResponseAsync(id, twin).toBlocking().single().body();
    }

    /**
     * Adds or replaces a digital twin.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     412 (Precondition Failed): The model is decommissioned or the digital twin already exists (when using If-None-Match: *).
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param twin The digital twin instance being added. If provided, the $dtId property is ignored.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> addAsync(String id, Object twin, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(addWithServiceResponseAsync(id, twin), serviceCallback);
    }

    /**
     * Adds or replaces a digital twin.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     412 (Precondition Failed): The model is decommissioned or the digital twin already exists (when using If-None-Match: *).
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param twin The digital twin instance being added. If provided, the $dtId property is ignored.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> addAsync(String id, Object twin) {
        return addWithServiceResponseAsync(id, twin).map(new Func1<ServiceResponseWithHeaders<Object, DigitalTwinsAddHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, DigitalTwinsAddHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Adds or replaces a digital twin.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     412 (Precondition Failed): The model is decommissioned or the digital twin already exists (when using If-None-Match: *).
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param twin The digital twin instance being added. If provided, the $dtId property is ignored.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, DigitalTwinsAddHeaders>> addWithServiceResponseAsync(String id, Object twin) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (twin == null) {
            throw new IllegalArgumentException("Parameter twin is required and cannot be null.");
        }
        final String ifNoneMatch = null;
        return service.add(id, twin, ifNoneMatch, this.client.apiVersion())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, DigitalTwinsAddHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, DigitalTwinsAddHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, DigitalTwinsAddHeaders> clientResponse = addDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Adds or replaces a digital twin.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     412 (Precondition Failed): The model is decommissioned or the digital twin already exists (when using If-None-Match: *).
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param twin The digital twin instance being added. If provided, the $dtId property is ignored.
     * @param ifNoneMatch Only perform the operation if the entity does not already exist. Possible values include: '*'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object add(String id, Object twin, String ifNoneMatch) {
        return addWithServiceResponseAsync(id, twin, ifNoneMatch).toBlocking().single().body();
    }

    /**
     * Adds or replaces a digital twin.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     412 (Precondition Failed): The model is decommissioned or the digital twin already exists (when using If-None-Match: *).
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param twin The digital twin instance being added. If provided, the $dtId property is ignored.
     * @param ifNoneMatch Only perform the operation if the entity does not already exist. Possible values include: '*'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> addAsync(String id, Object twin, String ifNoneMatch, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(addWithServiceResponseAsync(id, twin, ifNoneMatch), serviceCallback);
    }

    /**
     * Adds or replaces a digital twin.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     412 (Precondition Failed): The model is decommissioned or the digital twin already exists (when using If-None-Match: *).
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param twin The digital twin instance being added. If provided, the $dtId property is ignored.
     * @param ifNoneMatch Only perform the operation if the entity does not already exist. Possible values include: '*'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> addAsync(String id, Object twin, String ifNoneMatch) {
        return addWithServiceResponseAsync(id, twin, ifNoneMatch).map(new Func1<ServiceResponseWithHeaders<Object, DigitalTwinsAddHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, DigitalTwinsAddHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Adds or replaces a digital twin.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     412 (Precondition Failed): The model is decommissioned or the digital twin already exists (when using If-None-Match: *).
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param twin The digital twin instance being added. If provided, the $dtId property is ignored.
     * @param ifNoneMatch Only perform the operation if the entity does not already exist. Possible values include: '*'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, DigitalTwinsAddHeaders>> addWithServiceResponseAsync(String id, Object twin, String ifNoneMatch) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (twin == null) {
            throw new IllegalArgumentException("Parameter twin is required and cannot be null.");
        }
        return service.add(id, twin, ifNoneMatch, this.client.apiVersion())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, DigitalTwinsAddHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, DigitalTwinsAddHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, DigitalTwinsAddHeaders> clientResponse = addDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, DigitalTwinsAddHeaders> addDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(ErrorResponseException.class)
                .buildWithHeaders(response, DigitalTwinsAddHeaders.class);
    }

    /**
     * Deletes a digital twin. All relationships referencing the digital twin must already be deleted.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is no digital twin with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void delete(String id) {
        deleteWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Deletes a digital twin. All relationships referencing the digital twin must already be deleted.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is no digital twin with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteAsync(String id, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Deletes a digital twin. All relationships referencing the digital twin must already be deleted.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is no digital twin with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteAsync(String id) {
        return deleteWithServiceResponseAsync(id).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a digital twin. All relationships referencing the digital twin must already be deleted.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is no digital twin with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteWithServiceResponseAsync(String id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        final String ifMatch = null;
        return service.delete(id, ifMatch, this.client.apiVersion())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Deletes a digital twin. All relationships referencing the digital twin must already be deleted.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is no digital twin with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param ifMatch Only perform the operation if the entity's etag matches one of the etags provided or * is provided.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void delete(String id, String ifMatch) {
        deleteWithServiceResponseAsync(id, ifMatch).toBlocking().single().body();
    }

    /**
     * Deletes a digital twin. All relationships referencing the digital twin must already be deleted.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is no digital twin with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param ifMatch Only perform the operation if the entity's etag matches one of the etags provided or * is provided.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteAsync(String id, String ifMatch, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteWithServiceResponseAsync(id, ifMatch), serviceCallback);
    }

    /**
     * Deletes a digital twin. All relationships referencing the digital twin must already be deleted.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is no digital twin with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param ifMatch Only perform the operation if the entity's etag matches one of the etags provided or * is provided.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteAsync(String id, String ifMatch) {
        return deleteWithServiceResponseAsync(id, ifMatch).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a digital twin. All relationships referencing the digital twin must already be deleted.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is no digital twin with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param ifMatch Only perform the operation if the entity's etag matches one of the etags provided or * is provided.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteWithServiceResponseAsync(String id, String ifMatch) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.delete(id, ifMatch, this.client.apiVersion())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Updates a digital twin.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is no digital twin with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param patchDocument An update specification described by JSON Patch. Updates to property values and $model elements may happen in the same request. Operations are limited to add, replace and remove.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void update(String id, List<Object> patchDocument) {
        updateWithServiceResponseAsync(id, patchDocument).toBlocking().single().body();
    }

    /**
     * Updates a digital twin.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is no digital twin with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param patchDocument An update specification described by JSON Patch. Updates to property values and $model elements may happen in the same request. Operations are limited to add, replace and remove.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> updateAsync(String id, List<Object> patchDocument, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateWithServiceResponseAsync(id, patchDocument), serviceCallback);
    }

    /**
     * Updates a digital twin.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is no digital twin with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param patchDocument An update specification described by JSON Patch. Updates to property values and $model elements may happen in the same request. Operations are limited to add, replace and remove.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<Void> updateAsync(String id, List<Object> patchDocument) {
        return updateWithServiceResponseAsync(id, patchDocument).map(new Func1<ServiceResponseWithHeaders<Void, DigitalTwinsUpdateHeaders>, Void>() {
            @Override
            public Void call(ServiceResponseWithHeaders<Void, DigitalTwinsUpdateHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates a digital twin.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is no digital twin with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param patchDocument An update specification described by JSON Patch. Updates to property values and $model elements may happen in the same request. Operations are limited to add, replace and remove.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<ServiceResponseWithHeaders<Void, DigitalTwinsUpdateHeaders>> updateWithServiceResponseAsync(String id, List<Object> patchDocument) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (patchDocument == null) {
            throw new IllegalArgumentException("Parameter patchDocument is required and cannot be null.");
        }
        Validator.validate(patchDocument);
        final String ifMatch = null;
        return service.update(id, patchDocument, ifMatch, this.client.apiVersion())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Void, DigitalTwinsUpdateHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Void, DigitalTwinsUpdateHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Void, DigitalTwinsUpdateHeaders> clientResponse = updateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Updates a digital twin.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is no digital twin with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param patchDocument An update specification described by JSON Patch. Updates to property values and $model elements may happen in the same request. Operations are limited to add, replace and remove.
     * @param ifMatch Only perform the operation if the entity's etag matches one of the etags provided or * is provided.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void update(String id, List<Object> patchDocument, String ifMatch) {
        updateWithServiceResponseAsync(id, patchDocument, ifMatch).toBlocking().single().body();
    }

    /**
     * Updates a digital twin.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is no digital twin with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param patchDocument An update specification described by JSON Patch. Updates to property values and $model elements may happen in the same request. Operations are limited to add, replace and remove.
     * @param ifMatch Only perform the operation if the entity's etag matches one of the etags provided or * is provided.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> updateAsync(String id, List<Object> patchDocument, String ifMatch, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateWithServiceResponseAsync(id, patchDocument, ifMatch), serviceCallback);
    }

    /**
     * Updates a digital twin.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is no digital twin with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param patchDocument An update specification described by JSON Patch. Updates to property values and $model elements may happen in the same request. Operations are limited to add, replace and remove.
     * @param ifMatch Only perform the operation if the entity's etag matches one of the etags provided or * is provided.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<Void> updateAsync(String id, List<Object> patchDocument, String ifMatch) {
        return updateWithServiceResponseAsync(id, patchDocument, ifMatch).map(new Func1<ServiceResponseWithHeaders<Void, DigitalTwinsUpdateHeaders>, Void>() {
            @Override
            public Void call(ServiceResponseWithHeaders<Void, DigitalTwinsUpdateHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates a digital twin.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is no digital twin with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param patchDocument An update specification described by JSON Patch. Updates to property values and $model elements may happen in the same request. Operations are limited to add, replace and remove.
     * @param ifMatch Only perform the operation if the entity's etag matches one of the etags provided or * is provided.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<ServiceResponseWithHeaders<Void, DigitalTwinsUpdateHeaders>> updateWithServiceResponseAsync(String id, List<Object> patchDocument, String ifMatch) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (patchDocument == null) {
            throw new IllegalArgumentException("Parameter patchDocument is required and cannot be null.");
        }
        Validator.validate(patchDocument);
        return service.update(id, patchDocument, ifMatch, this.client.apiVersion())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Void, DigitalTwinsUpdateHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Void, DigitalTwinsUpdateHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Void, DigitalTwinsUpdateHeaders> clientResponse = updateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Void, DigitalTwinsUpdateHeaders> updateDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(ErrorResponseException.class)
                .buildWithHeaders(response, DigitalTwinsUpdateHeaders.class);
    }

    /**
     * Retrieves a relationship between two digital twins.
     Status codes:
     200 (OK): Success.
     404 (Not Found): There is either no digital twin or relationship with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param relationshipId The id of the relationship. The id is unique within the digital twin and case sensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getRelationshipById(String id, String relationshipId) {
        return getRelationshipByIdWithServiceResponseAsync(id, relationshipId).toBlocking().single().body();
    }

    /**
     * Retrieves a relationship between two digital twins.
     Status codes:
     200 (OK): Success.
     404 (Not Found): There is either no digital twin or relationship with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param relationshipId The id of the relationship. The id is unique within the digital twin and case sensitive.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getRelationshipByIdAsync(String id, String relationshipId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getRelationshipByIdWithServiceResponseAsync(id, relationshipId), serviceCallback);
    }

    /**
     * Retrieves a relationship between two digital twins.
     Status codes:
     200 (OK): Success.
     404 (Not Found): There is either no digital twin or relationship with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param relationshipId The id of the relationship. The id is unique within the digital twin and case sensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getRelationshipByIdAsync(String id, String relationshipId) {
        return getRelationshipByIdWithServiceResponseAsync(id, relationshipId).map(new Func1<ServiceResponseWithHeaders<Object, DigitalTwinsGetRelationshipByIdHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, DigitalTwinsGetRelationshipByIdHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Retrieves a relationship between two digital twins.
     Status codes:
     200 (OK): Success.
     404 (Not Found): There is either no digital twin or relationship with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param relationshipId The id of the relationship. The id is unique within the digital twin and case sensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, DigitalTwinsGetRelationshipByIdHeaders>> getRelationshipByIdWithServiceResponseAsync(String id, String relationshipId) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (relationshipId == null) {
            throw new IllegalArgumentException("Parameter relationshipId is required and cannot be null.");
        }
        return service.getRelationshipById(id, relationshipId, this.client.apiVersion())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, DigitalTwinsGetRelationshipByIdHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, DigitalTwinsGetRelationshipByIdHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, DigitalTwinsGetRelationshipByIdHeaders> clientResponse = getRelationshipByIdDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, DigitalTwinsGetRelationshipByIdHeaders> getRelationshipByIdDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(ErrorResponseException.class)
                .buildWithHeaders(response, DigitalTwinsGetRelationshipByIdHeaders.class);
    }

    /**
     * Adds a relationship between two digital twins.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is either no digital twin, target digital twin, or relationship with the provided id.
     409 (Conflict): A relationship with the provided id already exists.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param relationshipId The id of the relationship. The id is unique within the digital twin and case sensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object addRelationship(String id, String relationshipId) {
        return addRelationshipWithServiceResponseAsync(id, relationshipId).toBlocking().single().body();
    }

    /**
     * Adds a relationship between two digital twins.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is either no digital twin, target digital twin, or relationship with the provided id.
     409 (Conflict): A relationship with the provided id already exists.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param relationshipId The id of the relationship. The id is unique within the digital twin and case sensitive.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> addRelationshipAsync(String id, String relationshipId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(addRelationshipWithServiceResponseAsync(id, relationshipId), serviceCallback);
    }

    /**
     * Adds a relationship between two digital twins.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is either no digital twin, target digital twin, or relationship with the provided id.
     409 (Conflict): A relationship with the provided id already exists.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param relationshipId The id of the relationship. The id is unique within the digital twin and case sensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> addRelationshipAsync(String id, String relationshipId) {
        return addRelationshipWithServiceResponseAsync(id, relationshipId).map(new Func1<ServiceResponseWithHeaders<Object, DigitalTwinsAddRelationshipHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, DigitalTwinsAddRelationshipHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Adds a relationship between two digital twins.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is either no digital twin, target digital twin, or relationship with the provided id.
     409 (Conflict): A relationship with the provided id already exists.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param relationshipId The id of the relationship. The id is unique within the digital twin and case sensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, DigitalTwinsAddRelationshipHeaders>> addRelationshipWithServiceResponseAsync(String id, String relationshipId) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (relationshipId == null) {
            throw new IllegalArgumentException("Parameter relationshipId is required and cannot be null.");
        }
        final Object relationship = null;
        final String ifNoneMatch = null;
        return service.addRelationship(id, relationshipId, relationship, ifNoneMatch, this.client.apiVersion())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, DigitalTwinsAddRelationshipHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, DigitalTwinsAddRelationshipHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, DigitalTwinsAddRelationshipHeaders> clientResponse = addRelationshipDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Adds a relationship between two digital twins.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is either no digital twin, target digital twin, or relationship with the provided id.
     409 (Conflict): A relationship with the provided id already exists.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param relationshipId The id of the relationship. The id is unique within the digital twin and case sensitive.
     * @param relationship The data for the relationship.
     * @param ifNoneMatch Only perform the operation if the entity does not already exist. Possible values include: '*'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object addRelationship(String id, String relationshipId, Object relationship, String ifNoneMatch) {
        return addRelationshipWithServiceResponseAsync(id, relationshipId, relationship, ifNoneMatch).toBlocking().single().body();
    }

    /**
     * Adds a relationship between two digital twins.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is either no digital twin, target digital twin, or relationship with the provided id.
     409 (Conflict): A relationship with the provided id already exists.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param relationshipId The id of the relationship. The id is unique within the digital twin and case sensitive.
     * @param relationship The data for the relationship.
     * @param ifNoneMatch Only perform the operation if the entity does not already exist. Possible values include: '*'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> addRelationshipAsync(String id, String relationshipId, Object relationship, String ifNoneMatch, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(addRelationshipWithServiceResponseAsync(id, relationshipId, relationship, ifNoneMatch), serviceCallback);
    }

    /**
     * Adds a relationship between two digital twins.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is either no digital twin, target digital twin, or relationship with the provided id.
     409 (Conflict): A relationship with the provided id already exists.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param relationshipId The id of the relationship. The id is unique within the digital twin and case sensitive.
     * @param relationship The data for the relationship.
     * @param ifNoneMatch Only perform the operation if the entity does not already exist. Possible values include: '*'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> addRelationshipAsync(String id, String relationshipId, Object relationship, String ifNoneMatch) {
        return addRelationshipWithServiceResponseAsync(id, relationshipId, relationship, ifNoneMatch).map(new Func1<ServiceResponseWithHeaders<Object, DigitalTwinsAddRelationshipHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, DigitalTwinsAddRelationshipHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Adds a relationship between two digital twins.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is either no digital twin, target digital twin, or relationship with the provided id.
     409 (Conflict): A relationship with the provided id already exists.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param relationshipId The id of the relationship. The id is unique within the digital twin and case sensitive.
     * @param relationship The data for the relationship.
     * @param ifNoneMatch Only perform the operation if the entity does not already exist. Possible values include: '*'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, DigitalTwinsAddRelationshipHeaders>> addRelationshipWithServiceResponseAsync(String id, String relationshipId, Object relationship, String ifNoneMatch) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (relationshipId == null) {
            throw new IllegalArgumentException("Parameter relationshipId is required and cannot be null.");
        }
        return service.addRelationship(id, relationshipId, relationship, ifNoneMatch, this.client.apiVersion())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, DigitalTwinsAddRelationshipHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, DigitalTwinsAddRelationshipHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, DigitalTwinsAddRelationshipHeaders> clientResponse = addRelationshipDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, DigitalTwinsAddRelationshipHeaders> addRelationshipDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(ErrorResponseException.class)
                .buildWithHeaders(response, DigitalTwinsAddRelationshipHeaders.class);
    }

    /**
     * Deletes a relationship between two digital twins.
     Status codes:
     200 (OK): Success.
     404 (Not Found): There is either no digital twin or relationship with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param relationshipId The id of the relationship. The id is unique within the digital twin and case sensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteRelationship(String id, String relationshipId) {
        deleteRelationshipWithServiceResponseAsync(id, relationshipId).toBlocking().single().body();
    }

    /**
     * Deletes a relationship between two digital twins.
     Status codes:
     200 (OK): Success.
     404 (Not Found): There is either no digital twin or relationship with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param relationshipId The id of the relationship. The id is unique within the digital twin and case sensitive.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteRelationshipAsync(String id, String relationshipId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteRelationshipWithServiceResponseAsync(id, relationshipId), serviceCallback);
    }

    /**
     * Deletes a relationship between two digital twins.
     Status codes:
     200 (OK): Success.
     404 (Not Found): There is either no digital twin or relationship with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param relationshipId The id of the relationship. The id is unique within the digital twin and case sensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteRelationshipAsync(String id, String relationshipId) {
        return deleteRelationshipWithServiceResponseAsync(id, relationshipId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a relationship between two digital twins.
     Status codes:
     200 (OK): Success.
     404 (Not Found): There is either no digital twin or relationship with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param relationshipId The id of the relationship. The id is unique within the digital twin and case sensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteRelationshipWithServiceResponseAsync(String id, String relationshipId) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (relationshipId == null) {
            throw new IllegalArgumentException("Parameter relationshipId is required and cannot be null.");
        }
        final String ifMatch = null;
        return service.deleteRelationship(id, relationshipId, ifMatch, this.client.apiVersion())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteRelationshipDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Deletes a relationship between two digital twins.
     Status codes:
     200 (OK): Success.
     404 (Not Found): There is either no digital twin or relationship with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param relationshipId The id of the relationship. The id is unique within the digital twin and case sensitive.
     * @param ifMatch Only perform the operation if the entity's etag matches one of the etags provided or * is provided.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteRelationship(String id, String relationshipId, String ifMatch) {
        deleteRelationshipWithServiceResponseAsync(id, relationshipId, ifMatch).toBlocking().single().body();
    }

    /**
     * Deletes a relationship between two digital twins.
     Status codes:
     200 (OK): Success.
     404 (Not Found): There is either no digital twin or relationship with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param relationshipId The id of the relationship. The id is unique within the digital twin and case sensitive.
     * @param ifMatch Only perform the operation if the entity's etag matches one of the etags provided or * is provided.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteRelationshipAsync(String id, String relationshipId, String ifMatch, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteRelationshipWithServiceResponseAsync(id, relationshipId, ifMatch), serviceCallback);
    }

    /**
     * Deletes a relationship between two digital twins.
     Status codes:
     200 (OK): Success.
     404 (Not Found): There is either no digital twin or relationship with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param relationshipId The id of the relationship. The id is unique within the digital twin and case sensitive.
     * @param ifMatch Only perform the operation if the entity's etag matches one of the etags provided or * is provided.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteRelationshipAsync(String id, String relationshipId, String ifMatch) {
        return deleteRelationshipWithServiceResponseAsync(id, relationshipId, ifMatch).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a relationship between two digital twins.
     Status codes:
     200 (OK): Success.
     404 (Not Found): There is either no digital twin or relationship with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param relationshipId The id of the relationship. The id is unique within the digital twin and case sensitive.
     * @param ifMatch Only perform the operation if the entity's etag matches one of the etags provided or * is provided.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteRelationshipWithServiceResponseAsync(String id, String relationshipId, String ifMatch) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (relationshipId == null) {
            throw new IllegalArgumentException("Parameter relationshipId is required and cannot be null.");
        }
        return service.deleteRelationship(id, relationshipId, ifMatch, this.client.apiVersion())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteRelationshipDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteRelationshipDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Updates the properties on a relationship between two digital twins.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is either no digital twin or relationship with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param relationshipId The id of the relationship. The id is unique within the digital twin and case sensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void updateRelationship(String id, String relationshipId) {
        updateRelationshipWithServiceResponseAsync(id, relationshipId).toBlocking().single().body();
    }

    /**
     * Updates the properties on a relationship between two digital twins.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is either no digital twin or relationship with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param relationshipId The id of the relationship. The id is unique within the digital twin and case sensitive.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> updateRelationshipAsync(String id, String relationshipId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateRelationshipWithServiceResponseAsync(id, relationshipId), serviceCallback);
    }

    /**
     * Updates the properties on a relationship between two digital twins.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is either no digital twin or relationship with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param relationshipId The id of the relationship. The id is unique within the digital twin and case sensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<Void> updateRelationshipAsync(String id, String relationshipId) {
        return updateRelationshipWithServiceResponseAsync(id, relationshipId).map(new Func1<ServiceResponseWithHeaders<Void, DigitalTwinsUpdateRelationshipHeaders>, Void>() {
            @Override
            public Void call(ServiceResponseWithHeaders<Void, DigitalTwinsUpdateRelationshipHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the properties on a relationship between two digital twins.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is either no digital twin or relationship with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param relationshipId The id of the relationship. The id is unique within the digital twin and case sensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<ServiceResponseWithHeaders<Void, DigitalTwinsUpdateRelationshipHeaders>> updateRelationshipWithServiceResponseAsync(String id, String relationshipId) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (relationshipId == null) {
            throw new IllegalArgumentException("Parameter relationshipId is required and cannot be null.");
        }
        final List<Object> patchDocument = null;
        final String ifMatch = null;
        return service.updateRelationship(id, relationshipId, patchDocument, ifMatch, this.client.apiVersion())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Void, DigitalTwinsUpdateRelationshipHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Void, DigitalTwinsUpdateRelationshipHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Void, DigitalTwinsUpdateRelationshipHeaders> clientResponse = updateRelationshipDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Updates the properties on a relationship between two digital twins.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is either no digital twin or relationship with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param relationshipId The id of the relationship. The id is unique within the digital twin and case sensitive.
     * @param patchDocument JSON Patch description of the update to the relationship properties.
     * @param ifMatch Only perform the operation if the entity's etag matches one of the etags provided or * is provided.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void updateRelationship(String id, String relationshipId, List<Object> patchDocument, String ifMatch) {
        updateRelationshipWithServiceResponseAsync(id, relationshipId, patchDocument, ifMatch).toBlocking().single().body();
    }

    /**
     * Updates the properties on a relationship between two digital twins.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is either no digital twin or relationship with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param relationshipId The id of the relationship. The id is unique within the digital twin and case sensitive.
     * @param patchDocument JSON Patch description of the update to the relationship properties.
     * @param ifMatch Only perform the operation if the entity's etag matches one of the etags provided or * is provided.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> updateRelationshipAsync(String id, String relationshipId, List<Object> patchDocument, String ifMatch, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateRelationshipWithServiceResponseAsync(id, relationshipId, patchDocument, ifMatch), serviceCallback);
    }

    /**
     * Updates the properties on a relationship between two digital twins.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is either no digital twin or relationship with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param relationshipId The id of the relationship. The id is unique within the digital twin and case sensitive.
     * @param patchDocument JSON Patch description of the update to the relationship properties.
     * @param ifMatch Only perform the operation if the entity's etag matches one of the etags provided or * is provided.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<Void> updateRelationshipAsync(String id, String relationshipId, List<Object> patchDocument, String ifMatch) {
        return updateRelationshipWithServiceResponseAsync(id, relationshipId, patchDocument, ifMatch).map(new Func1<ServiceResponseWithHeaders<Void, DigitalTwinsUpdateRelationshipHeaders>, Void>() {
            @Override
            public Void call(ServiceResponseWithHeaders<Void, DigitalTwinsUpdateRelationshipHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the properties on a relationship between two digital twins.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is either no digital twin or relationship with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param relationshipId The id of the relationship. The id is unique within the digital twin and case sensitive.
     * @param patchDocument JSON Patch description of the update to the relationship properties.
     * @param ifMatch Only perform the operation if the entity's etag matches one of the etags provided or * is provided.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<ServiceResponseWithHeaders<Void, DigitalTwinsUpdateRelationshipHeaders>> updateRelationshipWithServiceResponseAsync(String id, String relationshipId, List<Object> patchDocument, String ifMatch) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (relationshipId == null) {
            throw new IllegalArgumentException("Parameter relationshipId is required and cannot be null.");
        }
        Validator.validate(patchDocument);
        return service.updateRelationship(id, relationshipId, patchDocument, ifMatch, this.client.apiVersion())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Void, DigitalTwinsUpdateRelationshipHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Void, DigitalTwinsUpdateRelationshipHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Void, DigitalTwinsUpdateRelationshipHeaders> clientResponse = updateRelationshipDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Void, DigitalTwinsUpdateRelationshipHeaders> updateRelationshipDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(ErrorResponseException.class)
                .buildWithHeaders(response, DigitalTwinsUpdateRelationshipHeaders.class);
    }

    /**
     * Retrieves the relationships from a digital twin.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is no digital twin with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RelationshipCollection object if successful.
     */
    public RelationshipCollection listRelationships(String id) {
        return listRelationshipsWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Retrieves the relationships from a digital twin.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is no digital twin with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RelationshipCollection> listRelationshipsAsync(String id, final ServiceCallback<RelationshipCollection> serviceCallback) {
        return ServiceFuture.fromResponse(listRelationshipsWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Retrieves the relationships from a digital twin.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is no digital twin with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RelationshipCollection object
     */
    public Observable<RelationshipCollection> listRelationshipsAsync(String id) {
        return listRelationshipsWithServiceResponseAsync(id).map(new Func1<ServiceResponse<RelationshipCollection>, RelationshipCollection>() {
            @Override
            public RelationshipCollection call(ServiceResponse<RelationshipCollection> response) {
                return response.body();
            }
        });
    }

    /**
     * Retrieves the relationships from a digital twin.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is no digital twin with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RelationshipCollection object
     */
    public Observable<ServiceResponse<RelationshipCollection>> listRelationshipsWithServiceResponseAsync(String id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        final String relationshipName = null;
        return service.listRelationships(id, relationshipName, this.client.apiVersion())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RelationshipCollection>>>() {
                @Override
                public Observable<ServiceResponse<RelationshipCollection>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RelationshipCollection> clientResponse = listRelationshipsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Retrieves the relationships from a digital twin.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is no digital twin with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param relationshipName The name of the relationship.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RelationshipCollection object if successful.
     */
    public RelationshipCollection listRelationships(String id, String relationshipName) {
        return listRelationshipsWithServiceResponseAsync(id, relationshipName).toBlocking().single().body();
    }

    /**
     * Retrieves the relationships from a digital twin.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is no digital twin with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param relationshipName The name of the relationship.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RelationshipCollection> listRelationshipsAsync(String id, String relationshipName, final ServiceCallback<RelationshipCollection> serviceCallback) {
        return ServiceFuture.fromResponse(listRelationshipsWithServiceResponseAsync(id, relationshipName), serviceCallback);
    }

    /**
     * Retrieves the relationships from a digital twin.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is no digital twin with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param relationshipName The name of the relationship.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RelationshipCollection object
     */
    public Observable<RelationshipCollection> listRelationshipsAsync(String id, String relationshipName) {
        return listRelationshipsWithServiceResponseAsync(id, relationshipName).map(new Func1<ServiceResponse<RelationshipCollection>, RelationshipCollection>() {
            @Override
            public RelationshipCollection call(ServiceResponse<RelationshipCollection> response) {
                return response.body();
            }
        });
    }

    /**
     * Retrieves the relationships from a digital twin.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is no digital twin with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param relationshipName The name of the relationship.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RelationshipCollection object
     */
    public Observable<ServiceResponse<RelationshipCollection>> listRelationshipsWithServiceResponseAsync(String id, String relationshipName) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.listRelationships(id, relationshipName, this.client.apiVersion())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RelationshipCollection>>>() {
                @Override
                public Observable<ServiceResponse<RelationshipCollection>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RelationshipCollection> clientResponse = listRelationshipsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RelationshipCollection> listRelationshipsDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<RelationshipCollection, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<RelationshipCollection>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Retrieves all incoming relationship for a digital twin.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is no digital twin with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IncomingRelationshipCollection object if successful.
     */
    public IncomingRelationshipCollection listIncomingRelationships(String id) {
        return listIncomingRelationshipsWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Retrieves all incoming relationship for a digital twin.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is no digital twin with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IncomingRelationshipCollection> listIncomingRelationshipsAsync(String id, final ServiceCallback<IncomingRelationshipCollection> serviceCallback) {
        return ServiceFuture.fromResponse(listIncomingRelationshipsWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Retrieves all incoming relationship for a digital twin.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is no digital twin with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IncomingRelationshipCollection object
     */
    public Observable<IncomingRelationshipCollection> listIncomingRelationshipsAsync(String id) {
        return listIncomingRelationshipsWithServiceResponseAsync(id).map(new Func1<ServiceResponse<IncomingRelationshipCollection>, IncomingRelationshipCollection>() {
            @Override
            public IncomingRelationshipCollection call(ServiceResponse<IncomingRelationshipCollection> response) {
                return response.body();
            }
        });
    }

    /**
     * Retrieves all incoming relationship for a digital twin.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is no digital twin with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IncomingRelationshipCollection object
     */
    public Observable<ServiceResponse<IncomingRelationshipCollection>> listIncomingRelationshipsWithServiceResponseAsync(String id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.listIncomingRelationships(id, this.client.apiVersion())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IncomingRelationshipCollection>>>() {
                @Override
                public Observable<ServiceResponse<IncomingRelationshipCollection>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IncomingRelationshipCollection> clientResponse = listIncomingRelationshipsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<IncomingRelationshipCollection> listIncomingRelationshipsDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<IncomingRelationshipCollection, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<IncomingRelationshipCollection>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Sends telemetry on behalf of a digital twin.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is no digital twin with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param telemetry The telemetry measurements to send from the digital twin.
     * @param dtId A unique message identifier (in the scope of the digital twin id) that is commonly used for de-duplicating messages.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void sendTelemetry(String id, Object telemetry, String dtId) {
        sendTelemetryWithServiceResponseAsync(id, telemetry, dtId).toBlocking().single().body();
    }

    /**
     * Sends telemetry on behalf of a digital twin.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is no digital twin with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param telemetry The telemetry measurements to send from the digital twin.
     * @param dtId A unique message identifier (in the scope of the digital twin id) that is commonly used for de-duplicating messages.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> sendTelemetryAsync(String id, Object telemetry, String dtId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(sendTelemetryWithServiceResponseAsync(id, telemetry, dtId), serviceCallback);
    }

    /**
     * Sends telemetry on behalf of a digital twin.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is no digital twin with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param telemetry The telemetry measurements to send from the digital twin.
     * @param dtId A unique message identifier (in the scope of the digital twin id) that is commonly used for de-duplicating messages.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> sendTelemetryAsync(String id, Object telemetry, String dtId) {
        return sendTelemetryWithServiceResponseAsync(id, telemetry, dtId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Sends telemetry on behalf of a digital twin.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is no digital twin with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param telemetry The telemetry measurements to send from the digital twin.
     * @param dtId A unique message identifier (in the scope of the digital twin id) that is commonly used for de-duplicating messages.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> sendTelemetryWithServiceResponseAsync(String id, Object telemetry, String dtId) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (telemetry == null) {
            throw new IllegalArgumentException("Parameter telemetry is required and cannot be null.");
        }
        if (dtId == null) {
            throw new IllegalArgumentException("Parameter dtId is required and cannot be null.");
        }
        final String dtTimestamp = null;
        return service.sendTelemetry(id, telemetry, dtId, dtTimestamp, this.client.apiVersion())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = sendTelemetryDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Sends telemetry on behalf of a digital twin.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is no digital twin with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param telemetry The telemetry measurements to send from the digital twin.
     * @param dtId A unique message identifier (in the scope of the digital twin id) that is commonly used for de-duplicating messages.
     * @param dtTimestamp An RFC 3339 timestamp that identifies the time the telemetry was measured.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void sendTelemetry(String id, Object telemetry, String dtId, String dtTimestamp) {
        sendTelemetryWithServiceResponseAsync(id, telemetry, dtId, dtTimestamp).toBlocking().single().body();
    }

    /**
     * Sends telemetry on behalf of a digital twin.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is no digital twin with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param telemetry The telemetry measurements to send from the digital twin.
     * @param dtId A unique message identifier (in the scope of the digital twin id) that is commonly used for de-duplicating messages.
     * @param dtTimestamp An RFC 3339 timestamp that identifies the time the telemetry was measured.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> sendTelemetryAsync(String id, Object telemetry, String dtId, String dtTimestamp, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(sendTelemetryWithServiceResponseAsync(id, telemetry, dtId, dtTimestamp), serviceCallback);
    }

    /**
     * Sends telemetry on behalf of a digital twin.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is no digital twin with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param telemetry The telemetry measurements to send from the digital twin.
     * @param dtId A unique message identifier (in the scope of the digital twin id) that is commonly used for de-duplicating messages.
     * @param dtTimestamp An RFC 3339 timestamp that identifies the time the telemetry was measured.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> sendTelemetryAsync(String id, Object telemetry, String dtId, String dtTimestamp) {
        return sendTelemetryWithServiceResponseAsync(id, telemetry, dtId, dtTimestamp).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Sends telemetry on behalf of a digital twin.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is no digital twin with the provided id.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param telemetry The telemetry measurements to send from the digital twin.
     * @param dtId A unique message identifier (in the scope of the digital twin id) that is commonly used for de-duplicating messages.
     * @param dtTimestamp An RFC 3339 timestamp that identifies the time the telemetry was measured.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> sendTelemetryWithServiceResponseAsync(String id, Object telemetry, String dtId, String dtTimestamp) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (telemetry == null) {
            throw new IllegalArgumentException("Parameter telemetry is required and cannot be null.");
        }
        if (dtId == null) {
            throw new IllegalArgumentException("Parameter dtId is required and cannot be null.");
        }
        return service.sendTelemetry(id, telemetry, dtId, dtTimestamp, this.client.apiVersion())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = sendTelemetryDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> sendTelemetryDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Sends telemetry on behalf of a component in a digital twin.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is either no digital twin with the provided id or the component path is invalid.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param componentPath The name of the DTDL component.
     * @param telemetry The telemetry measurements to send from the digital twin's component.
     * @param dtId A unique message identifier (in the scope of the digital twin id) that is commonly used for de-duplicating messages.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void sendComponentTelemetry(String id, String componentPath, Object telemetry, String dtId) {
        sendComponentTelemetryWithServiceResponseAsync(id, componentPath, telemetry, dtId).toBlocking().single().body();
    }

    /**
     * Sends telemetry on behalf of a component in a digital twin.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is either no digital twin with the provided id or the component path is invalid.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param componentPath The name of the DTDL component.
     * @param telemetry The telemetry measurements to send from the digital twin's component.
     * @param dtId A unique message identifier (in the scope of the digital twin id) that is commonly used for de-duplicating messages.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> sendComponentTelemetryAsync(String id, String componentPath, Object telemetry, String dtId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(sendComponentTelemetryWithServiceResponseAsync(id, componentPath, telemetry, dtId), serviceCallback);
    }

    /**
     * Sends telemetry on behalf of a component in a digital twin.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is either no digital twin with the provided id or the component path is invalid.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param componentPath The name of the DTDL component.
     * @param telemetry The telemetry measurements to send from the digital twin's component.
     * @param dtId A unique message identifier (in the scope of the digital twin id) that is commonly used for de-duplicating messages.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> sendComponentTelemetryAsync(String id, String componentPath, Object telemetry, String dtId) {
        return sendComponentTelemetryWithServiceResponseAsync(id, componentPath, telemetry, dtId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Sends telemetry on behalf of a component in a digital twin.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is either no digital twin with the provided id or the component path is invalid.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param componentPath The name of the DTDL component.
     * @param telemetry The telemetry measurements to send from the digital twin's component.
     * @param dtId A unique message identifier (in the scope of the digital twin id) that is commonly used for de-duplicating messages.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> sendComponentTelemetryWithServiceResponseAsync(String id, String componentPath, Object telemetry, String dtId) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (componentPath == null) {
            throw new IllegalArgumentException("Parameter componentPath is required and cannot be null.");
        }
        if (telemetry == null) {
            throw new IllegalArgumentException("Parameter telemetry is required and cannot be null.");
        }
        if (dtId == null) {
            throw new IllegalArgumentException("Parameter dtId is required and cannot be null.");
        }
        final String dtTimestamp = null;
        return service.sendComponentTelemetry(id, componentPath, telemetry, dtId, dtTimestamp, this.client.apiVersion())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = sendComponentTelemetryDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Sends telemetry on behalf of a component in a digital twin.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is either no digital twin with the provided id or the component path is invalid.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param componentPath The name of the DTDL component.
     * @param telemetry The telemetry measurements to send from the digital twin's component.
     * @param dtId A unique message identifier (in the scope of the digital twin id) that is commonly used for de-duplicating messages.
     * @param dtTimestamp An RFC 3339 timestamp that identifies the time the telemetry was measured.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void sendComponentTelemetry(String id, String componentPath, Object telemetry, String dtId, String dtTimestamp) {
        sendComponentTelemetryWithServiceResponseAsync(id, componentPath, telemetry, dtId, dtTimestamp).toBlocking().single().body();
    }

    /**
     * Sends telemetry on behalf of a component in a digital twin.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is either no digital twin with the provided id or the component path is invalid.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param componentPath The name of the DTDL component.
     * @param telemetry The telemetry measurements to send from the digital twin's component.
     * @param dtId A unique message identifier (in the scope of the digital twin id) that is commonly used for de-duplicating messages.
     * @param dtTimestamp An RFC 3339 timestamp that identifies the time the telemetry was measured.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> sendComponentTelemetryAsync(String id, String componentPath, Object telemetry, String dtId, String dtTimestamp, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(sendComponentTelemetryWithServiceResponseAsync(id, componentPath, telemetry, dtId, dtTimestamp), serviceCallback);
    }

    /**
     * Sends telemetry on behalf of a component in a digital twin.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is either no digital twin with the provided id or the component path is invalid.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param componentPath The name of the DTDL component.
     * @param telemetry The telemetry measurements to send from the digital twin's component.
     * @param dtId A unique message identifier (in the scope of the digital twin id) that is commonly used for de-duplicating messages.
     * @param dtTimestamp An RFC 3339 timestamp that identifies the time the telemetry was measured.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> sendComponentTelemetryAsync(String id, String componentPath, Object telemetry, String dtId, String dtTimestamp) {
        return sendComponentTelemetryWithServiceResponseAsync(id, componentPath, telemetry, dtId, dtTimestamp).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Sends telemetry on behalf of a component in a digital twin.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is either no digital twin with the provided id or the component path is invalid.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param componentPath The name of the DTDL component.
     * @param telemetry The telemetry measurements to send from the digital twin's component.
     * @param dtId A unique message identifier (in the scope of the digital twin id) that is commonly used for de-duplicating messages.
     * @param dtTimestamp An RFC 3339 timestamp that identifies the time the telemetry was measured.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> sendComponentTelemetryWithServiceResponseAsync(String id, String componentPath, Object telemetry, String dtId, String dtTimestamp) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (componentPath == null) {
            throw new IllegalArgumentException("Parameter componentPath is required and cannot be null.");
        }
        if (telemetry == null) {
            throw new IllegalArgumentException("Parameter telemetry is required and cannot be null.");
        }
        if (dtId == null) {
            throw new IllegalArgumentException("Parameter dtId is required and cannot be null.");
        }
        return service.sendComponentTelemetry(id, componentPath, telemetry, dtId, dtTimestamp, this.client.apiVersion())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = sendComponentTelemetryDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> sendComponentTelemetryDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Retrieves a component from a digital twin.
     Status codes:
     200 (OK): Success.
     404 (Not Found): There is either no digital twin with the provided id or the component path is invalid.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param componentPath The name of the DTDL component.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getComponent(String id, String componentPath) {
        return getComponentWithServiceResponseAsync(id, componentPath).toBlocking().single().body();
    }

    /**
     * Retrieves a component from a digital twin.
     Status codes:
     200 (OK): Success.
     404 (Not Found): There is either no digital twin with the provided id or the component path is invalid.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param componentPath The name of the DTDL component.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getComponentAsync(String id, String componentPath, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getComponentWithServiceResponseAsync(id, componentPath), serviceCallback);
    }

    /**
     * Retrieves a component from a digital twin.
     Status codes:
     200 (OK): Success.
     404 (Not Found): There is either no digital twin with the provided id or the component path is invalid.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param componentPath The name of the DTDL component.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getComponentAsync(String id, String componentPath) {
        return getComponentWithServiceResponseAsync(id, componentPath).map(new Func1<ServiceResponseWithHeaders<Object, DigitalTwinsGetComponentHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, DigitalTwinsGetComponentHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Retrieves a component from a digital twin.
     Status codes:
     200 (OK): Success.
     404 (Not Found): There is either no digital twin with the provided id or the component path is invalid.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param componentPath The name of the DTDL component.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, DigitalTwinsGetComponentHeaders>> getComponentWithServiceResponseAsync(String id, String componentPath) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (componentPath == null) {
            throw new IllegalArgumentException("Parameter componentPath is required and cannot be null.");
        }
        return service.getComponent(id, componentPath, this.client.apiVersion())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, DigitalTwinsGetComponentHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, DigitalTwinsGetComponentHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, DigitalTwinsGetComponentHeaders> clientResponse = getComponentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, DigitalTwinsGetComponentHeaders> getComponentDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(ErrorResponseException.class)
                .buildWithHeaders(response, DigitalTwinsGetComponentHeaders.class);
    }

    /**
     * Updates a component on a digital twin.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is either no digital twin with the provided id or the component path is invalid.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param componentPath The name of the DTDL component.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void updateComponent(String id, String componentPath) {
        updateComponentWithServiceResponseAsync(id, componentPath).toBlocking().single().body();
    }

    /**
     * Updates a component on a digital twin.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is either no digital twin with the provided id or the component path is invalid.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param componentPath The name of the DTDL component.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> updateComponentAsync(String id, String componentPath, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateComponentWithServiceResponseAsync(id, componentPath), serviceCallback);
    }

    /**
     * Updates a component on a digital twin.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is either no digital twin with the provided id or the component path is invalid.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param componentPath The name of the DTDL component.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<Void> updateComponentAsync(String id, String componentPath) {
        return updateComponentWithServiceResponseAsync(id, componentPath).map(new Func1<ServiceResponseWithHeaders<Void, DigitalTwinsUpdateComponentHeaders>, Void>() {
            @Override
            public Void call(ServiceResponseWithHeaders<Void, DigitalTwinsUpdateComponentHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates a component on a digital twin.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is either no digital twin with the provided id or the component path is invalid.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param componentPath The name of the DTDL component.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<ServiceResponseWithHeaders<Void, DigitalTwinsUpdateComponentHeaders>> updateComponentWithServiceResponseAsync(String id, String componentPath) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (componentPath == null) {
            throw new IllegalArgumentException("Parameter componentPath is required and cannot be null.");
        }
        final List<Object> patchDocument = null;
        final String ifMatch = null;
        return service.updateComponent(id, componentPath, patchDocument, ifMatch, this.client.apiVersion())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Void, DigitalTwinsUpdateComponentHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Void, DigitalTwinsUpdateComponentHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Void, DigitalTwinsUpdateComponentHeaders> clientResponse = updateComponentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Updates a component on a digital twin.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is either no digital twin with the provided id or the component path is invalid.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param componentPath The name of the DTDL component.
     * @param patchDocument An update specification described by JSON Patch. Updates to property values and $model elements may happen in the same request. Operations are limited to add, replace and remove.
     * @param ifMatch Only perform the operation if the entity's etag matches one of the etags provided or * is provided.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void updateComponent(String id, String componentPath, List<Object> patchDocument, String ifMatch) {
        updateComponentWithServiceResponseAsync(id, componentPath, patchDocument, ifMatch).toBlocking().single().body();
    }

    /**
     * Updates a component on a digital twin.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is either no digital twin with the provided id or the component path is invalid.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param componentPath The name of the DTDL component.
     * @param patchDocument An update specification described by JSON Patch. Updates to property values and $model elements may happen in the same request. Operations are limited to add, replace and remove.
     * @param ifMatch Only perform the operation if the entity's etag matches one of the etags provided or * is provided.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> updateComponentAsync(String id, String componentPath, List<Object> patchDocument, String ifMatch, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateComponentWithServiceResponseAsync(id, componentPath, patchDocument, ifMatch), serviceCallback);
    }

    /**
     * Updates a component on a digital twin.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is either no digital twin with the provided id or the component path is invalid.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param componentPath The name of the DTDL component.
     * @param patchDocument An update specification described by JSON Patch. Updates to property values and $model elements may happen in the same request. Operations are limited to add, replace and remove.
     * @param ifMatch Only perform the operation if the entity's etag matches one of the etags provided or * is provided.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<Void> updateComponentAsync(String id, String componentPath, List<Object> patchDocument, String ifMatch) {
        return updateComponentWithServiceResponseAsync(id, componentPath, patchDocument, ifMatch).map(new Func1<ServiceResponseWithHeaders<Void, DigitalTwinsUpdateComponentHeaders>, Void>() {
            @Override
            public Void call(ServiceResponseWithHeaders<Void, DigitalTwinsUpdateComponentHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates a component on a digital twin.
     Status codes:
     200 (OK): Success.
     400 (Bad Request): The request is invalid.
     404 (Not Found): There is either no digital twin with the provided id or the component path is invalid.
     *
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param componentPath The name of the DTDL component.
     * @param patchDocument An update specification described by JSON Patch. Updates to property values and $model elements may happen in the same request. Operations are limited to add, replace and remove.
     * @param ifMatch Only perform the operation if the entity's etag matches one of the etags provided or * is provided.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<ServiceResponseWithHeaders<Void, DigitalTwinsUpdateComponentHeaders>> updateComponentWithServiceResponseAsync(String id, String componentPath, List<Object> patchDocument, String ifMatch) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (componentPath == null) {
            throw new IllegalArgumentException("Parameter componentPath is required and cannot be null.");
        }
        Validator.validate(patchDocument);
        return service.updateComponent(id, componentPath, patchDocument, ifMatch, this.client.apiVersion())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Void, DigitalTwinsUpdateComponentHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Void, DigitalTwinsUpdateComponentHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Void, DigitalTwinsUpdateComponentHeaders> clientResponse = updateComponentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Void, DigitalTwinsUpdateComponentHeaders> updateComponentDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(ErrorResponseException.class)
                .buildWithHeaders(response, DigitalTwinsUpdateComponentHeaders.class);
    }

}
